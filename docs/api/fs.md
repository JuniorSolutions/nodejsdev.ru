# File system

!!!success "Стабильность: 2 – Стабильная"

    АПИ является удовлетворительным. Совместимость с NPM имеет высший приоритет и не будет нарушена кроме случаев явной необходимости.

Файл ввода / вывода обеспечивается простыми упаковщиками (программное средство создания системной оболочки для стандартизации внешних обращений и изменения функциональной ориентации действующей системы) вокруг стандартных функций POSIX (Portable Operating System Interface for Computer Environment for Unix - интерфейс переносимой операционной системы).

Для использования этого модуля выполните `require('fs')`. Все методы имеют асинхронные и синхронные формы.

Асинхронная форма всегда принимает завершающий обратный вызов в качестве последнего аргумента. Аргументы, передаваемые на завершающий обратный вызов зависят от метода, но первый аргумент всегда зарезервирован для исключения. Если операция была завершена успешно, то первый аргумент будет `null` или `undefined`.

При использовании синхронной формы любые исключения сразу выдаются. Вы можете использовать `try`/`catch` для обработки исключений или позволить им увеличиваться в количестве.

Вот пример асинхронной версии:

```js
const fs = require('fs');

fs.unlink('/tmp/hello', (err) => {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});
```

Вот синхронная версия:

```js
const fs = require('fs');

fs.unlinkSync('/tmp/hello');
console.log('successfully deleted /tmp/hello');
```

При использовании асинхронных методов не существует гарантированного упорядочивания. Таким образом, следующее склонно к ошибке:

```js
fs.rename('/tmp/hello', '/tmp/world', (err) => {
  if (err) throw err;
  console.log('renamed complete');
});

fs.stat('/tmp/world', (err, stats) => {
  if (err) throw err;
  console.log(`stats: ${JSON.stringify(stats)}`);
});
```

`fs.stat` может выполняется перед `fs.rename`. Правильный способ сделать это – выстроить по цепочке обратные вызовы.

```js
fs.rename('/tmp/hello', '/tmp/world', (err) => {
  if (err) throw err;
  fs.stat('/tmp/world', (err, stats) => {
    if (err) throw err;
    console.log(`stats: ${JSON.stringify(stats)}`);
  });
});
```

В нагруженных процессах программисту настоятельно рекомендуется использовать асинхронные версии этих вызовов. Синхронные версии будут блокировать весь процесс, пока они не будут выполнены - прекращая все соединения.

Может быть использован связанный путь к имени файла. Однако, помните, что этот путь будет связан с `process.cwd()`. Большинство `fs` функций позволяют вам пропускать аргумент обратного вызова. Если вы это сделали, то используется обратный вызов по умолчанию, который выдает ошибки снова. Чтобы получить след на оригинальный сайт вызова, установите окружение `NODE_DEBUG` изменяющимся.

```
$ cat script.js
function bad() {
  require('fs').readFile('/');
}
bad();

$ env NODE_DEBUG = fs node script.js
fs.js:88
        throw backtrace;
        ^
Error: EISDIR: illegal operation on a directory, read
```

## Буферный API

`fs` функции поддерживают передачу и прием путей, как со строками, так и с буферами. Последние предназначены, чтобы сделать возможной работу с файловыми системами, которые разрешают имена файлов «не UTF-8».

Для большинства типичных использований, работа с путями в качестве буферов будет излишней, так как строка API преобразует в, а так же из UTF-8 автоматически.

Обратите внимание, что на некоторых файловых системах (например, NTFS и HFS+) имена файлов будут всегда кодированы как UTF-8. На таких файловых системах, которые передают не-UTF-8 закодированные Буферы функциям `fs` не будут работать должным образом.

## Класс fs.FSWatcher

Объекты, возвращаемые `fs.watch()` относятся к этому типу.

Обратный вызов `listener` предоставляемый `fs.watch()` получает возвращаемые FSWatcher события.

Объект самостоятельно создает эти события:

### Событие change

`eventType` `<Строка>`
: Тип изменения `fs`

`filename` `<Строка>` | `<Буфер>`
: Имя файла, которое изменилось (если релевантно / доступно)

Генерируется когда что-то меняется в отслеживаемом каталоге или файле. Смотрите больше деталей в `fs.watch()`.

Аргумент `filename` может быть не предусмотрен в зависимости от поддержки операционной системы.

Если `filename` предоставляется, то в качестве `Buffer`, если `fs.watch()` вызывается с его опцией `encoding` установленной на `buffer`, в противном случае `filename` будет с именем строки.

```js
// Example when handled through fs.watch listener
fs.watch(
  './tmp',
  { encoding: 'buffer' },
  (eventType, filename) => {
    if (filename) console.log(filename);
    // Prints: <Buffer ...>
  }
);
```

### Событие error

`error` `<Error>`

Генерируется когда создается событие.

### watcher.close()

Прекратить наблюдение за изменениями на данном `fs.FSWatcher`.

## Класс fs.ReadStream

`ReadStream` это ЧИТАЕМЫЙ ПОТОК.

### Событие close

Генерируется когда базовый дескриптор файла `ReadStream` был закрыт с помощью метода `fs.close()`.

### Событие open

`fd` `<Integer>`
: Дескриптор файла `Integer`, используемый `ReadStream`.

Он генерируется когда открывается файл в `ReadStream`.

### readStream.bytesRead

Число байтов прочтенных до настоящего времени.

### readStream.path

Путь к файлу поток читает исходя из того, как указано в первом аргументе `fs.createReadStream()`. Если `path` передается в виде строки, то `readStream.path` будет строкой.

Если путь к файлу передается в качестве буфера, то `readStream.path` будет буфером.

## Класс fs.Stats

Объекты возвращаемые от `fstat()`, `vs.lstat()` и `fs.fstat()` и их синхронные аналоги относятся к этому типу.

- `stats.isFile()`
- `stats.isDirectory()`
- `stats.isBlockDevice()`
- `stats.isCharacterDevice()`
- `stats.isSymbolicLink()` (действует только с `fs.lstat()`)
- `stats.isFIFO()`
- `stats.isSocket()`

Для обычного файла `util.inspect(stats)` будет возвращать строку очень похожую на эту:

```
{
  dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT
}
```

Обратите внимание, что `atime`, `mtime`, `birthtime` и `ctime` являются экземплярами объекта `Date` и чтобы сравнить значения этих объектов вы должны использовать соответствующие методы.

Для более общих случаев `GetTime()` возвращает количество миллисекунд, прошедшее с 1 января 1970 года 00:00:00 UTC, и этого числа должно быть достаточно для любого сравнения, однако существуют дополнительные методы, которые могут быть использованы для отображения нечеткой информации. Более подробную информацию можно найти на странице MDN JavaScript Reference.

### Stat Time Values

Времена в объекте `stat` имеют следующие значения:

`Atime`
: "Время доступа" - время, когда данные файла последний раз использовались. Меняется в системных вызовах `MKNOD(2)`, `utimes(2)`, и `read(2)`.

`mtime`
: "время изменения" - время, когда данные файла последний раз менялись. Меняется с помощью системных вызовов `mknod(2)`, `utimes(2)`, и `write(2)`.

`ctime`
: "Время изменения" - время, когда статус файла последний раз менялся (модификация данных индексного дескриптора).. Меняется с помощью системных вызовов `chmod(2)`, `chown(2)`, `link(2)`, `mknod(2)`, `rename(2)`, `unlink(2)`, `utimes(2)`, `read(2)`, и `write(2)`.

`birthtime`
: "Время рождения" - время создания файла. Установить один раз при создании файла. На файловых системах, где `birthtime` не доступен, это поле может вместо этого содержать либо `ctime` или `1970-01-01T00: 00Z` (т. е. метка времени `0` эпохи Unix). Обратите внимание, что это значение может быть больше, чем `atime` или `mtime` в этом случае. На Darwin и других вариантах FreeBSD, также устанавливается если `atime` явно устанавливается на более раннее значение, чем значение текущего `birthtime` с использованием системного вызова `utimes(2)`.

До Node v0.12, `ctime` поддерживал `birthtime` на системах Windows. Следует отметить, что по состоянию на v0.12, `ctime` не является "временем создания", также как и на системах Unix.

## Класс fs.WriteStream

`WriteStream` это перезаписываемый поток

### Событие close

Генерируется когда основной дескриптор файла `WriteStream` был закрыт с помощью метода `fs.close()`.

### Событие open

`fd` `<Число>`
: Дескриптор файла, используемый `WriteStream`. Генерируется когда открывается файл в `WriteStream`

### writeStream.bytesWritten

Число байтов, записанных на данный момент. Не включает в себя данные, которые до сих пор в очереди для записи.

### writeStream.path

Поток пишет путь к файлу как указано в первом аргументе в `fs.createWriteStream()`. Если путь к файлу передается в виде строки, то `writeStream.path` будет строкой. Если путь к файлу передается в качестве буфера, то `writeStream.path` будет буфером.

## fs.access()

```
fs.access(path[, mode], callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`
- `callback` - `<Функция>`

Проверяет разрешения пользователя для файла или каталога указанного путем.

Аргумент `mode` является необязательным целым числом, которое задает выполнение проверки доступности. Следующие константы определяют возможные значения `mode` (режима). Можно создать маску, состоящую из побитового (поразрядного), или состоящие из двух или более значений.

`fs.constants.F_OK`
: Путь виден вызывающему процессу. Это полезно для определения того, чтобы узнать существует ли файл, но ничего не говорит о правах доступа к RWX. Установлен по умолчанию, если не указан режим.

`fs.constants.R_OK`
: Путь может быть прочитан вызывающим процессом.

`fs.constants.W_OK`
: Путь может быть записан вызывающим процессом.

`fs.constants.X_OK`
: Путь может быть выполнен вызывающим процессом. Это не работает на Windows (будет вести себя как `constants.F_OK`).

Последний аргумент, обратный вызов, является функцией обратного вызова, которая вызывается с возможным аргументом ошибки. Если какая-нибудь из проверок доступности терпит неудачу, то аргумент ошибки будет заполняться. В следующем примере проверяется может ли быть считан и записан текущим процессом файл / пароль / и т. д.

```js
fs.access(
  '/etc/passwd',
  fs.constants.R_OK | fs.constants.W_OK,
  (err) => {
    console.log(err ? 'no access!' : 'can read/write');
  }
);
```

Не рекомендуется использовать `fs.access()`, что бы проверить доступность файла перед вызовом `fs.open()`, `fs.readFile()` или `fs.writeFile()`. Таким образом, можно наблюдать гонку процессов, так как другие процессы могут изменить состояние файла между двумя вызовами. Вместо этого пользовательский код должен открывать/читать/записывать файл напрямую и обрабатывать ошибки доступа к файлу.

Например:

Запись файла НЕ РЕКОМЕНДУЕТСЯ

```js
fs.access('myfile', (err) => {
  if (!err) {
    console.error('myfile already exists');
    return;
  }

  fs.open('myfile', 'wx', (err, fd) => {
    if (err) throw err;
    writeMyData(fd);
  });
});
```

Запись файла РЕКОМЕНДУЕТСЯ

```js
fs.open('myfile', 'wx', (err, fd) => {
  if (err) {
    if (err.code === 'EEXIST') {
      console.error('myfile already exists');
      return;
    } else {
      throw err;
    }
  }

  writeMyData(fd);
});
```

Чтение файла НЕ РЕКОМЕНДУЕТСЯ

```js
fs.access('myfile', (err) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile does not exist');
      return;
    } else {
      throw err;
    }
  }

  fs.open('myfile', 'r', (err, fd) => {
    if (err) throw err;
    readMyData(fd);
  });
});
```

Чтение файла РЕКОМЕНДУЕТСЯ

```js
fs.open('myfile', 'r', (err, fd) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile does not exist');
      return;
    } else {
      throw err;
    }
  }

  readMyData(fd);
});
```

## fs.accessSync()

```
fs.accessSync(path[, mode])
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`

Синхронная версия `fs.access()`. Это выдается если происходят сбои в проверках доступности, если нет, то не выдается ничего.

## fs.appendFile()

```
fs.appendFile(file, data[, options], callback)
```

`file` - `<Строка>` | `<Буфер>` | `<Число>`
: имя файла или файловый дескриптор.

`data` - `<Строка>` | `<Буфер>`
: Данные

`options` - `<Объект>` | `<Строка>`
: - `encoding` - `<Строка>` | `<Null>` по умолчанию `utf8`
: - `mode` - `<Число>` по умолчанию `0o666`
: - `flag` - `<Строка>` по умолчанию = `a`

`callback` - `<Функция>`
: функция обратного вызова

Данный метод позволяет асинхронно добавить данные в файл, создавая файл, если он еще не существует. Данные могут быть строкой или буфером.

Пример:

```js
fs.appendFile('message.txt', 'data to append', (err) => {
  if (err) throw err;
  console.log('The "data to append" was appended to file!');
});
```

Если `options` является строкой, то он указывает кодировку

```js
fs.appendFile(
  'message.txt',
  'data to append',
  'utf8',
  callback
);
```

Любой заданный дескриптор файла должен быть открыт для добавления.

!!!note "Примечание"

    Если дескриптор файла указан как `file`, то он не будет автоматически закрыт.

## fs.appendFileSync()

```
fs.appendFileSync(file, data[, options])
```

`file` - `<Строка>` | `<Буфер>` | `<Число>`
: имя файла или файловый дескриптор.

`data` - `<Строка>` | `<Буфер>`
: Данные

`options` - `<Объект>` | `<Строка>`
: - `encoding` - `<Строка>` | `<Null>` по умолчанию = `utf8`
: - `mode` - `<Число>` по умолчанию = `0o666`
: - `flag` - `<Строка>` по умолчанию = `a`

Синхронная версия `fs.appendFile()`. Возвращает следущее: `undefined`.

## fs.chmod()

```
fs.chmod(path, mode, callback)
```

- `path` - `<Строка>` | `<Буфер>`;
- `mode` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `chmod(2)`.

Никакие другие аргументы кроме возможного исключения не задаются завершающему обратному вызову.

## fs.chmodSync()

```
fs.chmodSync(path, mode)
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`

Синхронный `chmod(2)`. Возвращает следующее `undefined`.

## fs.chown()

```
fs.chown(path, uid, gid, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `uid` - `<Число>`
- `gid` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `chown(2)`. Никакие другие аргументы кроме возможного исключения не задаются завершающему обратному вызову.

## fs.chownSync()

```
fs.chownSync(path, uid, gid)
```

- `path` - `<Строка>` | `<Буфер>`
- `uid` - `<Число>`
- `gid` - `<Число>`

Синхронный `chown(2)`. Возвращает следующее `undefined`.

## fs.close()

```
fs.close(fd, callback)
```

- `fd` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `close(2)`. Никакие другие аргументы кроме возможного исключения не задаются завершающему обратному вызову.

## fs.closeSync()

```
fs.closeSync(fd)
```

- `fd` - `<Число>`

Синхронный `close(2)`. Возвращает следующее `undefined`.

## fs.constants

Возвращает объект, содержащий часто используемые константы для операций с файловой системой.

### Константы файлового доступа

Следующие константы предназначены для использования с `fs.access()`.

| Константа | Описание                                                                |
| --------- | ----------------------------------------------------------------------- |
| `F_OK`    | Флаг, указывающий, что файл является видимым для вызывающего процесса.  |
| `R_OK`    | Флаг, указывающий, что файл может быть прочитан и вызывающим процессом. |
| `W_OK`    | Флаг, указывающий, что файл может быть записан вызывающим процессом.    |
| `X_OK`    | Флаг, указывающий, что файл может быть выполнен вызывающим процессом.   |

### Константы открытия файла

Следующие константы предназначены для использования с `fs.open()`.

| Константа     | Описание                                                                                                                                                                                                                         |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `O_RDONLY`    | Флаг, указывающий, что нужно открыть файл для доступа в режиме чтения.                                                                                                                                                           |
| `O_WRONLY`    | Флаг, указывающий, что нужно открыть файл для доступа в режиме записи.                                                                                                                                                           |
| `O_RDWR`      | Флаг, указывающий, что нужно открыть файл для доступа в режиме чтение-запись.                                                                                                                                                    |
| `O_CREAT`     | Флаг, указывающий, что нужно создать файл если он еще не существует.                                                                                                                                                             |
| `O_EXCL`      | Флаг, указывающий, что открытие файла должно потерпеть неудачу, если установлен флаг `O_CREAT` установлен и файл уже существует.                                                                                                 |
| `O_NOCTTY`    | Флаг, указывающий на то, что если путь идентифицирует оконечное (терминальное) устройство, то открытие пути не приведет к тому, что терминал станет управляющим терминалом для процесса (если у процесса все еще нет терминала). |
| `O_TRUNC`     | Флаг, указывающий на то, что если файл существует и является обычным файлом, и этот файл успешно открыт для доступа записи, то его длина должна быть усечена до нуля.                                                            |
| `O_APPEND`    | Флаг, указывающий, что данные будут добавлены в конец файла.                                                                                                                                                                     |
| `O_DIRECTORY` | Флаг, указывающий, что открытие должно завершиться неудачей, если путь не является директорией.                                                                                                                                  |
| `O_NOATIME`   | Флаг, указывающий на то, что получение доступа для чтения к файловой системе больше не будет приводить к обновлению информации об `atime`, связанной с файлом. Этот флаг доступен только в операционных системах Linux.          |
| `O_NOFOLLOW`  | Флаг, указывающий, что открытие должно завершиться неудачей, если путь является символической ссылкой.                                                                                                                           |
| `O_SYNC`      | Флаг, указывающий, что файл открывается для синхронного сигнала ввода / вывода.                                                                                                                                                  |
| `O_SYMLINK`   | Флаг, указывающий, что нужно открыть саму символическую ссылку, а не ресурс, на который она указывает.                                                                                                                           |
| `O_DIRECT`    | Когда установлена эта константа, то будет сделана попытка свести к минимуму эффекты кэширования файлов ввода / вывода.                                                                                                           |
| `O_NONBLOCK`  | Флаг, указывающий на открытие файла в режиме без блокировки (позволяющем выполнять следующую операцию даже в случае невозможности полного завершения предшествующей) в случаях, когда это возможно.                              |

### Константы типа файла

Следующие константы предназначены для использования c атрибутом mode объекта `fs.Stats` для определения типа файла.

| Константа  | Описание                                                                                                                                                                         |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `S_IFMT`   | Битовая маска, используемая для извлечения кода типа файла.                                                                                                                      |
| `S_IFREG`  | Постоянная типа файла для обычного файла.                                                                                                                                        |
| `S_IFDIR`  | Константа типа файла для каталога.                                                                                                                                               |
| `S_IFCHR`  | Константа типа файла для файла с символьно-ориентированного устройства.                                                                                                          |
| `S_IFBLK`  | Константа типа файла для файла блочно-ориентированного устройства.                                                                                                               |
| `S_IFIFO`  | Константа типа файла для FIFO (от First In First Out "первым пришёл - первым обслужен"; "звенья следуют в порядке их поступления" - принцип очереди; / pipe (программный канал). |
| `S_IFLNK`  | Константа типа файла для символической ссылки.                                                                                                                                   |
| `S_IFSOCK` | Константа типа файла для сокета.                                                                                                                                                 |

### Константы режимов файла

Следующие константы предназначены для использования c атрибутом mode объекта `fs.Stats` для определения разрешений доступа для файла.

| Константа | Описание                                                               |
| --------- | ---------------------------------------------------------------------- |
| `S_IRWXU` | Режим файла, указывающий на чтение, запись и выполнение пользователем. |
| `S_IRUSR` | Режим файла, указывающий на чтение пользователем.                      |
| `S_IWUSR` | Режим файла указывающий на запись пользователем.                       |
| `S_IXUSR` | Режим файла указывает на выполнение пользователем.                     |
| `S_IRWXG` | Режим файла, указывающий на чтение, запись и выполнение группой.       |
| `S_IRGRP` | Режим файла, указывающий на чтение группой.                            |
| `S_IWGRP` | Режим файла указывающий на запись группой.                             |
| `S_IXGRP` | Режим файла указывает на выполнение группой.                           |
| `S_IRWXO` | Режим файла, указывающий на чтение, запись и выполнение другими.       |
| `S_IROTH` | Режим файла, указывающий на чтение другими.                            |
| `S_IWOTH` | Режим файла указывающий на запись другими.                             |
| `S_IXOTH` | Режим файла указывает на выполнение другими.                           |

## fs.createReadStream()

```
fs.createReadStream(path[, options])
```

`path` - `<Строка>` | `<Буфер>`
: Путь

`options` - `<Строка>` | `<Объект>`
: - `flags` - `<Строка>`
: - `encoding` - `<Строка>`
: - `fd` - `<Число>`
: - `mode` - `<Число>`
: - `autoClose` - `<Boolean>`
: - `Start` - `<Число>`
: - `End` - `<Число>`

Возвращает новый объект `ReadStream`.

Имейте в виду, что, в отличие от значения по умолчанию, установленного для `highWaterMark` на считываемый поток (16 Кб), поток, возвращаемый этим методом имеет значение по умолчанию 64 кб для такого же параметра.

`options` является объектом или строкой со следующими параметрами по умолчанию:

```js
{
  flags: 'r',
  encoding: null,
  fd: null,
  mode: 0o666,
  autoClose: true
}
```

`options` могут включать в себя `start` (начальные) и `end` (конечные ) значения для чтения определенного диапазона байтов из файла, а не весь файл. И `start` и `end` суммарны и начинаются с `0`

Кодирование может быть одним из таких, которые принимает `Buffer`. Если `fd` указан, то `ReadStream` будет игнорировать аргумент `path` и будет использовать указанный дескриптор файла.

Это означает, что событие `open` не будет создано. Обратите внимание, что `fd` должен быть блокирующим; неблокирующие `fd` должны быть переданы `net.Socket`. Если `autoclose` ложный, то дескриптор файла не будет закрыт, даже если произошла ошибка. Это ваша закрыть его и убедитесь, что нет утечки дескриптора файла. Если `autoClose` установлено значение `true` (поведение по умолчанию), при `error` или `end` дескриптор файла будет автоматически закрыт.

`mode` устанавливает режим файла (разрешение и второй промежуточный бит округления), но только если файл был создан. Пример для чтения последних `10` байт файла, который имеет длину `100` байт:

```js
fs.createReadStream('sample.txt', { start: 90, end: 99 });
```

Если `options` является строкой, то она определяет кодировку.

## fs.createWriteStream(path[, options])

```
fs.createWriteStream(path[, options])
```

`path` - `<Строка>` | `<Буфер>`
: Путь

`options` - `<Строка>` | `<Объект>`
: - `flags` - `<Строка>`
: - `defaultEncoding` - `<Строка>`
: - `fd` - `<Число>`
: - `mode` - `<Число>`
: - `autoClose` - `<Boolean>`
: - `Start` - `<Число>`

Возвращает новый объект `WriteStream`. `options` является объектом или строкой со следующими параметрами по умолчанию:

```js
{
  flags: 'w',
  defaultEncoding: 'utf8',
  fd: null,
  mode: 0o666,
  autoClose: true
}
```

`options` могут также включать в себя опцию `start`, чтобы разрешить запись данных в какой-то позиции, следующей за началом файла.

Модификация файла, а не его замена может потребовать режим flags `r+` а не в режим по умолчанию `w`. `DefaultEncoding` может быть любой из тех, что примет `Buffer`.

Если `autoClose` установлено значение `true` (поведение по умолчанию) в случае ошибки или завершения дескриптор файла будет автоматически закрыт.

Если `autoClose` `false`, то дескриптор файла не будет закрыт, даже если есть ошибка. Это ваша обязанность закрыть его и убедиться, что нет утечки дескриптора файла.

Как и в случае с `ReadStream`, если указан `fd`, то `WriteStream` будет игнорировать аргумент `path` и будет использовать указанный дескриптор файла. Это означает, что событие `open` не будет создано. Обратите внимание, что `fd` должен быть блокирующим; неблокирующие `fd` должны быть переданы `net.Socket`. Если `options` является строкой, то она указывает кодировку.

## fs.exists()

!!!danger "Стабильность: 0 – Не рекомендуется"

    Используйте вместо этого `fs.stat()` или `fs.access()`

```
fs.exists(path, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Проверьте, существует ли данный путь, проверяя с файловой системой. Затем вызовите аргумент `callback` со значением `true` или `false`.

Пример:

```js
fs.exists('/etc/passwd', (exists) => {
  console.log(exists ? "it's there" : 'no passwd!');
});
```

`fs.exists()` не должен использоваться, чтобы проверить, существует ли файл перед вызовом `fs.open()`. Это вводит состояние гонок, так как другие процессы могут изменить состояние файла между двумя вызовами.

Вместо этого код пользователя должен вызвать `fs.open()` напрямую и обрабатывать вызванную ошибку, если файл не существует.

## fs.existsync()

!!!danger "Стабильность: 0 – Не рекомендуется"

    Используйте вместо этого `fs.statSync()` или `fs.accessSync()`

```
fs.existsync(path)
```

- `path` - `<Строка>` | `<Буфер>`

Синхронная версия `fs.exists()`. Показывает `true` если файл существует, `false` если не существует.

## fs.fchmod()

```
fs.fchmod(fd, mode, callback)
```

- `fd` - `<Число>`
- `mode` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `fchmod(2)`.

Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.fchmodSync()

```
fs.fchmodSync(fd, mode)
```

- `fd` - `<Число>`
- `mode` - `<Число>`

Синхронный `fchmod(2)`. Показывает `undefined`.

## fs.fchown()

```
fs.fchown(fd, uid, gid, callback)
```

- `fd` - `<Число>`
- `uid` - `<Число>`
- `gid` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `fchown(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.fchownSync()

```
fs.fchownSync(fd, uid, gid)
```

- `fd` - `<Число>`
- `uid` - `<Число>`
- `gid` - `<Число>`

Синхронный `fchown(2)`. Показывает `undefined`.

## fs.fdatasync()

```
fs.fdatasync(fd, callback)
```

- `fd` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `fdatasync(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.fdatasyncSync()

```
fs.fdatasyncSync(fd)
```

- `fd` - `<Число>`

Синхронный `fdatasync(2)`. Показывает `undefined`.

## fs.fstat()

```
fs.fstat(fd, callback)
```

- `fd` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `fstat(2)`.

Обратный вызов получает два аргумента `(err, stats)`, где `stats` является объектом `fs.Stats`.

`fstat()` идентична `stat()`, за исключением того, что файл который будет обработан `stat()` задается дескриптором файла `fd`.

## fs.fstatSync()

```
fs.fstatSync(fd)
```

- `fd` - `<Число>`

Синхронный `fstat(2)`. Возвращает запрос `fs.Stats`.

## fs.fsync()

```
fs.fsync(fd, callback)
```

- `fd` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `fsync(2)`.

Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.fsyncSync()

```
fs.fsyncSync(fd)
```

- `fd` - `<Число>`

Синхронный `fsync(2)`. Показывает `undefined`.

## fs.ftruncate()

```
fs.ftruncate(fd, len, callback)
```

- `fd` - `<Число>`
- `len` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `ftruncate(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

Если файл на который ссылается файловый дескриптор был больше, чем количество байтов `len`, то в таком случае только первые `len` байты будут сохранены в файле.

Например, следующая программа сохраняет только первые четыре байта файла.

```js
console.log(fs.readFileSync('temp.txt', 'utf8'));
// prints Node.js

// get the file descriptor of the file to be truncated
const fd = fs.openSync('temp.txt', 'r+');

// truncate the file to first four bytes
fs.ftruncate(fd, 4, (err) => {
  assert.ifError(err);
  console.log(fs.readFileSync('temp.txt', 'utf8'));
});
// prints Node
```

Если файл оказался короче `len`, то оставшаяся часть будет заполнена нулевыми байтами (`\0`)

Например:

```js
console.log(fs.readFileSync('temp.txt', 'utf-8'));
// prints Node.js

// get the file descriptor of the file to be truncated
const fd = fs.openSync('temp.txt', 'r+');

// truncate the file to 10 bytes, whereas the actual size is 7 bytes
fs.ftruncate(fd, 10, (err) => {
  assert.ifError(!err);
  console.log(fs.readFileSync('temp.txt'));
});
// prints <Buffer 4e 6f 64 65 2e 6a 73 00 00 00>
// ('Node.js\0\0\0' in UTF8)
```

## fs.ftruncateSync()

```
fs.ftruncateSync(fd, len)
```

- `fd` - `<Число>`
- `len` - `<Число>`

Синхронный `ftruncate(2)`. Показывает `undefined`.

## fs.futimes()

```
fs.futimes(fd, atime, mtime, callback)
```

- `fd` - `<Число>`
- `atime` - `<Число>`
- `mtime` - `<Число>`
- `callback` - `<Функция>`

Меняет временные метки файла, на который ссылается файловый дескриптор.

## fs.futimesSync()

```
fs.futimesSync(fd, atime, mtime)
```

- `fd` - `<Число>`
- `atime` - `<Число>`
- `mtime` - `<Число>`

Синхронная версия `fs.futimes()`. Показывает `undefined`.

## fs.lchmod()

```
fs.lchmod(path, mode, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `lchmod(2)`.

Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову. Доступно только на Mac OS X

## fs.lchmodSync()

```
fs.lchmodSync(path, mode)
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`

Синхронный `lchmod(2)`. Показывает `undefined`.

## fs.lchown()

```
fs.lchown(path, uid, gid, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `uid` - `<Число>`
- `gid` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `lchown(2)`.

Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.lchownSync()

```
fs.lchownSync(path, uid, gid)
```

- `path` - `<Строка>` | `<Буфер>`
- `uid` - `<Число>`
- `gid` - `<Число>`

Синхронный `lchown(2)`. Показывает `undefined`.

## fs.link()

```
fs.link(srcpath, dstpath, callback)
```

- `srcpath` - `<Строка>` | `<Буфер>`
- `dstpath` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `link(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.linkSync()

```
fs.linkSync(srcpath, dstpath)
```

- `srcpath` - `<Строка>` | `<Буфер>`
- `dstpath` - `<Строка>` | `<Буфер>`

Синхронный `link(2)`. Показывает `undefined`.

## fs.lstat()

```
fs.lstat(path, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `lstat(2)`.

Обратный вызов получает два аргумента `(err, stats)` где `stats` является объектом `fs.Stats.lstat()` идентичен `stat()`, за исключением того, что, если `path` является символической ссылкой, то именно ссылка обрабатывается `stat`, а не тот файл на который она ссылается.

## fs.lstatSync()

```
fs.lstatSync(path)
```

- `path` - `<Строка>` | `<Буфер>`

Синхронный `lstat(2)`. Возвращает запрос `fs.Stats`.

## fs.mkdir()

```
fs.mkdir(path[, mode], callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`
- `callback` - `<Функция>`

Асинхронный `mkdir(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову. `mode` устанавливается по умолчанию на значение `0o777`.

## fs.mkdirSync()

```
fs.mkdirSync(path[, mode])
```

- `path` - `<Строка>` | `<Буфер>`
- `mode` - `<Число>`

Синхронный `mkdir(2)`. Показывает `undefined`.

## fs.mkdtemp()

```
fs.mkdtemp(prefix[, options], callback)
```

- `prefix` - `<Строка>`
- `options` `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)
- `callback` - `<Функция>`

Создает уникальный временный каталог. Формирует шесть случайных символов, добавляемых за необходимый `prefix`, чтобы создать уникальный временный каталог.

Созданный путь к папке передается в виде строки второму параметру обратного вызова.

Пример:

```js
fs.mkdtemp('/tmp/foo-', (err, folder) => {
  if (err) throw err;
  console.log(folder);
  // Prints: /tmp/foo-itXde2
});
```

!!!note "Примечание"

    Метод `fs.mkdtemp()` добавит шесть произвольно выбранных символов непосредственно в строку `prefix`.

Например, директории задается `/tmp`, если нужно создать временный каталог в `/tmp`, префикс должен отделяться наклонной специальным разделителем пути (`require('path').sep`).

```js
// The parent directory for the new temporary directory
const tmpDir = '/tmp';

// This method is *INCORRECT*:
fs.mkdtemp(tmpDir, (err, folder) => {
  if (err) throw err;
  console.log(folder);
  // Will print something similar to `/tmpabc123`.
  // Note that a new temporary directory is created
  // at the file system root rather than *within*
  // the /tmp directory.
});

// This method is *CORRECT*:
const path = require('path');
fs.mkdtemp(tmpDir + path.sep, (err, folder) => {
  if (err) throw err;
  console.log(folder);
  // Will print something similar to `/tmp/abc123`.
  // A new temporary directory is created within
  // the /tmp directory.
});
```

## fs.mkdtempSync()

```
fs.mkdtempSync(prefix[, options])
```

- `prefix` - `<Строка>`
- `options` `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)

Синхронная версия `fs.mkdtemp()`. Показывает путь созданной папки.

## fs.open()

```
fs.open(path, flags[, mode], callback)
```

- `path` - `<Строка>` | `<Буфер>` (Строка/ Буфер)
- `flags` - `<Строка>` | `<Число>` (Строка/ Буфер)
- `mode` - `<Число>`
- `callback` - `<Функция>`

Открыт асинхронный файл. Смотрите `open(2)`.

`flags` могут быть:

`r`
: Открыть файл для чтения. Исключение возникает, если файл не существует.

`r+`
: Открыть файл для чтения и записи. Исключение возникает, если файл не существует.

`rs+`
: Открыть файл для чтения и записи в синхронном режиме. Инструктирует операционную систему, чтобы обойти кэш локальный файловой системы.
: Это в первую очередь полезно для открытия файлов на сборках NFS (Network File System/ сетевая файловая система), поскольку это позволяет пропустить потенциально старый локальный кэш. Она имеет очень реальное влияние на производительность ввода / вывода, поэтому не используйте этот флаг, до тех пор пока вам это не нужно.
: Обратите внимание, что это не превратит `fs.open()` в синхронно блокирующий вызов. Если это то, что вы хотите, то вы должны использовать `fs.openSync()`

`w`
: Открыть файл для записи. Файл создается (если он не существует) или сокращается (если он существует).

`wx`
: как `w`, но не срабатывает, если существует путь.

`w+`
: Открыть файл для чтения и записи. Файл создается (если он не существует) или сокращается (если он существует).

`wx+`
: как `w+`, но не срабатывает, если существует путь.

`a`
: Открыть файл для добавления. Файл создается, если он не существует.

`ax`
: как `a`, но терпит неудачу, если существует путь.

`a+`
: Открыть файл для чтения и добавления. Файл создается, если он не существует.

`ax+`
: как `a+`, но не срабатывавет, если существует путь.

`mode` устанавливает режим файла (разрешение и второй промежуточный бит округления), но только если файл был создан. По умолчанию это `0666`, для чтения и записи.

Обработчик получает два аргумента `(err, fd)`.

Эксклюзивный флаг `х` (`O_EXCL` флаг в `open(2)`) гарантирует, что `path` вновь создан. На системах POSIX, `path` считается существующим, даже если он является символьной ссылкой на несуществующий файл. Исключающий флаг может или не может работать с Network File System сетевыми файловыми системами.

`flags` также могут быть числом документируемым с помощью `open(2)`; обычно используемые константы доступны из `fs.constants`. В операционной системе Windows, флаги переводятся в их эквиваленты, где это применимо, например `O_WRONGLY` в `FILE_GENERIC_WRITE` или `O_EXCL | O_CREAT` в `CREATE_NEW`, который был принят `CreateFileW`.

В Linux, позиционные записи не работают, если файл открыт в режиме добавления. Ядро игнорирует позиционный аргумент и всегда добавляет данные в конец файла.

!!!note "Примечание"

    Поведение `fs.open()` зависит от платформы для некоторых флагов. Например, открытие каталога на OS X и Linux с помощью флага `a+` - смотри пример ниже - возвратит ошибку. В отличие от этого, на Windows, и FreeBSD, файловый дескриптор будет возвращен.

```js
// OS X and Linux
fs.open('<directory>', 'a+', (err, fd) => {
  // => [Error: EISDIR: illegal operation on a directory, open ]
});

// Windows and FreeBSD
fs.open('<directory>', 'a+', (err, fd) => {
  // => null,
});
```

## fs.openSync()

```
fs.openSync(path, flags[, mode])
```

- `path` - `<Строка>` | `<Буфер>`
- `flags` - `<Строка>` | `<Число>` (Строка/ Буфер)
- `mode` - `<Число>`

Синхронная версия `fs.open()`. Возвращает целое число, представляющее дескриптор файла.

## fs.read()

```
fs.read(fd, buffer, offset, length, position, callback)
```

`fd` - `<Число>`
: Считывание данных из файла, указанного `fd`.

- `buffer` - `<Строка>` | `<Буфер>`
  : `buffer` является буфером, куда будут записаны данные.

- `offset` - `<Число>`
  : `offset` смещение в буфере, чтобы начать запись на нем.

- `length` - `<Число>`
  : `length` представляет собой целое число, определяющее количество байтов для чтения.

- `position` - `<Число>`
  : `position` целое число, определяющее, где начать чтение из файла Если позиция имеет нулевое значение, данные будут прочитаны с текущей позиции файла.

- `callback` - `<Функция>`
  : Обратный вызов получает три аргумента, `(err, BytesRead, buffer)`.

## fs.readSync()

```
fs.readSync(fd, buffer, offset, length, position)
```

- `fd` - `<Число>`
- `buffer` - `<Строка>` | `<Буфер>`
- `offset` - `<Число>`
- `length` - `<Число>`
- `position` - `<Число>`

Синхронная версия `fs.read()`. Возвращает количество `bytesRead`.

## fs.readdir()

```
fs.readdir(path[, options], callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)
- `callback` - `<Функция>`

Асинхронный `readdir(3)`. Считывает содержимое каталога. Обратный вызов получает два аргумента `(err, files)`, где `files` представляет собой массив имен файлов в директории исключая `'.'` а также `'..'`.

Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим схему кодирования символов, чтобы использовать ее для имен файлов, переданных в функцию обратного вызова. Если `encoding` устанавливается как `buffer`, имена файлов которые возвращаются будут переданы в качестве объектов `Buffer`.

## fs.readdirSync()

```
fs.readdirSync(path[, options])
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)

Синхронный `readdir(3)`. Возвращает массив имен файлов исключая `'.'` а также `'..'`.

Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим схему кодирования символов, чтобы использовать ее для имен файлов, переданных в функцию обратного вызова. Если `encoding` устанавливается как `buffer`, имена файлов которые возвращаются будут переданы в качестве объектов `Buffer`.

## fs.readFile()

```
fs.readFile(file[, options], callback)
```

- `file` - `<Строка>` | `<Буфер>` | `<Число>` имя файла или файловый дескриптор
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)
- - `flag` - `<Строка>` (по умолчанию `r`)
- `callback` - `<Функция>`

Асинхронно читает все содержимое файла. Пример:

```js
fs.readFile('/etc/passwd', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

Обратному вызову передается два аргумента `(err, data)`, где `data` это содержимое файла.

Если не указано кодирования, тогда возвращается исходный буфер. Если `options` является строкой, то она определяет кодировку. Пример:

```js
fs.readFile('/etc/passwd', 'utf8', callback);
```

Любой указанный дескриптор файла должен поддерживать чтение.

!!!note "Примечание"

    Если дескриптор файла указан как `file`, он не будет автоматически закрыт.

## fs.readFileSync()

```
fs.readFileSync(file[, options])
```

- `file` - `<Строка>` | `<Буфер>` | `<Число>` имя файла или файловый дескриптор
- `options` - `<Строка>` | `<Объект>`
- `encoding` - `<Строка>` (по умолчанию `utf8`)
- `flag` - `<Строка>` (по умолчанию `r`)

Синхронная версия `fs.readFile`. Возвращает содержимое файла. Если опция `encoding` задана, то эта функция возвращает строку. В противном случае она возвращает буфер.

## fs.readlink()

```
fs.readlink(path[, options], callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- `encoding` - `<Строка>` (по умолчанию `utf8`)
- `callback` - `<Функция>`

Асинхронный `readlink(2)`. Обратный вызов получает два аргумента `(err, linkString)`.

Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим схему кодирования символов, чтобы использовать ее для имен файлов, переданных в функцию обратного вызова.

Если `encoding` устанавливается как `buffer`, имена файлов которые возвращаются будут переданы в качестве объектов `Buffer`.

## fs.readlinkSync()

```
fs.readlinkSync(path[, options])
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)

Синхронный `readlink(2)`. Возвращает значение строки символической ссылки.

Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим схему кодирования символов, чтобы использовать ее для имен файлов, переданных в функцию обратного вызова.

Если `encoding` устанавливается как `buffer`, имена файлов которые возвращаются будут переданы в качестве объектов `Buffer`.

## fs.realpath()

```
fs.realpath(path[, options], callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)
- `callback` - `<Функция>`

Асинхронный `realpath(3)`. Обратный вызов получает два аргумента `(err, resolvedPath)`. Может использовать `process.cwd` для разрешения относительных путей. Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим символьную кодировку, используемую для того чтобы путь был передан обратному вызову.

Если `encoding` устанавливается как `buffer`, то путь, который возвращается будет передан в качестве объекта `Buffer`.

## fs.realpathSync()

```
fs.realpathSync(path[, options])
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
- - `encoding` - `<Строка>` (по умолчанию `utf8`)

Синхронный `realpath(3)`. Возвращает полученный путь. Дополнительный аргумент `options` может быть строкой, определяющей кодировку, или объектом со свойством `encoding` определяющим символьную кодировку, используемую для того чтобы путь был передан обратному вызову. Если `encoding` устанавливается как `buffer`, то путь, который возвращается будет передан в качестве объекта `Buffer`.

## fs.rename()

```
fs.rename(oldPath, newPath, callback)
```

- `oldPath` - `<Строка>` | `<Буфер>`
- `newPath` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `rename(2)`.

Никакие другие аргументы кроме возможного исключения не задаются завершающему обратному вызову.

## fs.renameSync()

```
fs.renameSync(oldPath, newPath)
```

`oldPath` - `<Строка>` | `<Буфер>`
`newPath` - `<Строка>` | `<Буфер>`

Синхронный `rename(2)`. Возвращает `undefined`.

## fs.rmdir()

```
fs.rmdir(path, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `rmdir(2)`.

Никакие другие аргументы кроме возможного исключения не задаются завершающему обратному вызову.

## fs.rmdirSync()

```
fs.rmdirSync(path)
```

- `path` - `<Строка>` | `<Буфер>`

Синхронный `rmdir(2)`. Показывает `undefined`.

## fs.stat()

```
fs.stat(path, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `stat(2)`.

Обратный вызов получает два аргумента `(err, stats)`, где `stats` это объект `fs.Stats`. Смотрите раздел `fs.Stats` для дальнейшей информации.

## fs.statSync()

```
fs.statSync(path)
```

- `path` - `<Строка>` | `<Буфер>`

Синхронный `stat(2)`. Показывает запрос `fs.Stats`.

## fs.symlink()

```
fs.symlink(target, path[, type], callback)
```

- `target` - `<Строка>` | `<Буфер>`
- `path` - `<Строка>` | `<Буфер>`
- `type` - `<Строка>`
- `callback` - `<Функция>`

Асинхронный `symlink(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову. Аргумент type может быть установлен `dir`, `file` или `junction` (по умолчанию `file`) и доступен только в ОС Windows (игнорируется на других платформах).

Обратите внимание, что точки соединения Windows требуют полный путь назначения. При использовании `junction`, аргумент `target` будет автоматически стандартизован к полному пути. Пример:

```js
fs.symlink('./foo', './new-port');
```

Он создает символическую ссылку с именем `"new-port"`, которая указывает на `"foo"`.

## fs.symlinkSync()

```
fs.symlinkSync(target, path[, type])
```

- `target` - `<Строка>` | `<Буфер>`
- `path` - `<Строка>` | `<Буфер>`
- `type` - `<Строка>`

Синхронный `symlink(2)`. Возвращает `undefined`.

## fs.truncate()

```
fs.truncate(path, len, callback)
```

`path` - `<Строка>` | `<Буфер>`
`len` - `<Число>` (по умолчанию `0`)
`callback` - `<Функция>`

Асинхронный `truncate(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову. Дескриптор файла также может быть передан в качестве первого аргумента. В этом случае вызывается `fs.ftruncate()`.

## fs.truncateSync()

```
fs.truncateSync(path, len)
```

`path` - `<Строка>` | `<Буфер>`
`len` - `<Число>` (по умолчанию `0`)

Синхронный `truncate(2)`. Показывает `undefined`.

## fs.unlink()

```
fs.unlink(path, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `callback` - `<Функция>`

Асинхронный `unlink(2)`. Никакие другие аргументы кроме возможного исключения не заданы завершающему обратному вызову.

## fs.unlinkSync()

```
fs.unlinkSync(path)
```

- `path` - `<Строка>` | `<Буфер>`

Синхронный `unlink(2)`. Показывает `undefined`.

## fs.utimes()

```
fs.utimes(path, atime, mtime, callback)
```

- `path` - `<Строка>` | `<Буфер>`
- `atime` - `<Число>`
- `mtime` - `<Число>`
- `callback` - `<Функция>`

Изменение временных файла на который ссылается путь.

!!!note "Примечание"

    Аргументы `atime` и `mtime` следующих смежных функций следуют следующим правилам:

    - Если значение является исчислимой строкой, как например '123456789', то значение будет преобразовано в соответствующее число.
    - Если значение равно `NaN` или бесконечность, то значение будет преобразовано в `Date.now()`.

## fs.utimesSync()

```
fs.utimesSync(path, atime, mtime)
```

- `path` - `<Строка>` | `<Буфер>`
- `atime` - `<Число>`
- `mtime` - `<Число>`

Синхронная версия `fs.utimes()`. Возвращает `undefined`.

## fs.watch()

```
fs.watch(filename[, options][, listener])
```

- `path` - `<Строка>` | `<Буфер>`
- `options` - `<Строка>` | `<Объект>`
  : - `persistent` - `<Boolean>`. Указывает, должен ли процесс продолжается до тех пор, пока файлы отслеживаются. (По умолчанию - `true`)
  : - `recursive` - `<Boolean>` Указывает, должны ли отслеживаться все подкаталоги, или только текущий каталог. Применяется, когда вы указываете каталог, и только на поддерживаемых платформах (см. предупреждения). (По умолчанию - `false`)
  : - `encoding` - `<Строка>` Задает символьную кодировку, которая будет использоваться для имени файла, переданного обработчику. (По умолчанию - `UTF-8`).
- `listener` - `<Функция>`

Следит за изменениями в имени файла, где имя файла либо файл либо каталог. Возвращаемый объект является `fs.FSWatcher`.

Второй аргумент является необязательным. Если `options` предоставляется в виде строки, она указывает кодировку. В противном случае `options` должны быть переданы в качестве объекта.

Обратный вызов обработчика событий получает два аргумента `(eventType, filename)`. `eventType` это либо `rename` (переименовать) либо `change` (изменить), и `filename` - это имя того файла, который вызвал событие.

Пожалуйста, обратите внимание, что обработчик обратного вызова присоединяется к событию `change`, запущенному `fs.FSWatcher`, но они не являются одним и тем же.

### Предупреждения

Интерфейс прикладного программирования `fs.watch` API не на 100% совместим с разными платформами, и недоступен в некоторых ситуациях.

Рекурсивная опция поддерживается только на OS X и Windows.

### Доступность

Эта функция зависит от используемой операционной системы, обеспечивающей возможность получать уведомления об изменениях в файловой системе.

- В системах Linux, использует `inotify`
- В системах BSD, это использует `kqueue`
- На OS X, использует `kqueue` для файлов и `FSEvents` для каталогов.
- В системах SunOS (в том числе Solaris и SmartOS), это использует `eventports`.
- В системах Windows, эта функция зависит от `ReadDirectoryChangesW`.
- В системах AIX, эта функция зависит от `AHAFS`, который должен быть включен.

Если базовая функция недоступна по какой-то причине, то `fs.watch` не сможет функционировать.

Например, просмотр файлов или каталогов может быть ненадежным, а в некоторых случаях невозможным, на сетевых файловых системах (NFS, SMB и т. д.), или хост файловых системах при использовании программного обеспечения для виртуализации, таких как Vagrant, Docker и т. д.

Однако Вы все еще можете использовать `fs.watchFile`, который использует `stat` полинг ((последовательный) опрос, метод контроля последовательности доступа к среде передачи передающих устройств, при котором периферийным станциям посылается запрос, предлагающий передать имеющиеся данные), но он медленнее и менее надежен.

### Индексные дескрипторы

В системах Linux и OS X, `fs.watch()` определяет путь к `inode` и отслеживает `inode`.

Если отслеживаемый путь удален или создан заново, то ему присваивается новый `inode`.

Отслеживание создаст событие для удаления, но все равно будет продолжать отслеживание оригинального `inode`. События для нового `inode` не будут созданы. Так и должно происходить.

### Аргумент имени файла

Предоставление аргумента `filename` в обратном вызове поддерживается только на Linux и Windows. Даже на поддерживаемых платформах, `filename` не всегда будет предоставлен. Таким образом, не считается, что аргумент `filename` всегда предоставляется в обратном вызове, и имеет логику (последовательность операций, выполняемых программно) возврата в исходный режим, если он равен нулю.

```js
fs.watch('somedir', (eventType, filename) => {
  console.log(`event type is: ${eventType}`);
  if (filename) {
    console.log(`filename provided: ${filename}`);
  } else {
    console.log('filename not provided');
  }
});
```

## fs.watchFile()

```
fs.watchFile(filename[, options], listener)
```

- `filename` - `<Строка>` | `<Буфер>`
- `options` - `<Объект>`
  : - `persistent` - `<Boolean>`
  : - `interval` - `<Число>`
- `listener` - `<Функция>`

Следит за изменениями в `filename`. Обработчик обратного вызова будет вызываться каждый раз, когда происходит обращение к файлу.

Аргумент `options` может не приниматься во внимание. Если он предоставляется, то он должен быть объектом. Объект `options` может содержать `persistent` с булево логическим именем, указывающее, должен ли этот процесс продолжается до тех пор, пока файлы отслеживаются. Объект `options` может указывать (`interval`) свойство интервала, указывающее на то, как часто цель должна быть опрошена в миллисекундах.

По умолчанию `{ persistent: true, interval: 5007 }`

Обработчик `listener` получает два аргумента

- текущий объект stat
- и предыдущий объект stat

```js
fs.watchFile('message.text', (curr, prev) => {
  console.log(`the current mtime is: ${curr.mtime}`);
  console.log(`the previous mtime was: ${prev.mtime}`);
});
```

Эти объекты `stat` являются экземплярами `fs.stat`.

Если вы хотите получать уведомления, когда файл был изменен, а не только когда к нему получали доступ, то вам нужно сравнить `curr.mtime` и `prev.mtime`.

Примечание: когда результат операции `fs.watchFile` приводит к ошибке `ENOENT` то он будет ссылаться на обработчик только один раз, при этом все поля обнуляются (или для дат, эпоха Unix).

В операционной системе Windows поля `blksize` и `blocks` будут `undefined` (неопределенными), вместо `zero` (нуля).

Если файл создан позже, то обработчик будет вызван еще раз с последними объектами `stat`. Это изменение в функциональности начиная с версии V0.10.

!!!warning "Обратите внимание"

    `fs.watch()` более эффективен чем `fs.watchFile` и `fs.unwatchFile`. `fs.watch` должен быть использован вместо `fs.watchFile` и `fs.unwatchFile` в тех случаях когда это возможно.

## fs.unwatchFile()

```
fs.unwatchFile(filename[, listener])
```

- `filename` - `<Строка>` | `<Буфер>`
- `listener` - `<Функция>`

Остановить отслеживание изменений на `filename`. Если `listener` задан, то только этот конкретный обработчик удаляется.

В противном случае, все слушатели будут удалены, и вы фактически перестаете отслеживать `filename`.

Вызов `fs.unwatchFile()` с именем файла, который не отслеживается является холостой (пустой) командой, а не ошибкой.

!!!warning "Обратите внимание"

    `fs.watch()` более эффективен чем `fs.watchFile` и `fs.unwatchFile`. `fs.watch` должен быть использован вместо `fs.watchFile` и `fs.unwatchFile` в тех случаях когда это возможно.

## fs.write()

```
fs.write(fd, buffer, offset, length[, position], callback)
```

- `fd` - `<Число>`
- `buffer` - `<Строка>` | `<Буфер>`
- `offset` - `<Число>`
- `length` - `<Число>`
- `position` - `<Число>`
- `callback` - `<Функция>`

Запись `buffer` в файл, указанный с помощью `fd`.

`offset` и `length` определяют часть буфера для записи.

`position` относится к смещение от начала файла, в котором эти данные должны быть записаны.

Если `typeof position !== 'number'`, данные будут записаны в текущей позиции. См `pwrite(2)`.

Обратному вызову будет дано три аргумента `(err, written , buffer)`, где `written` указывает, сколько байтов были записано от `buffer`. Обратите внимание, что небезопасно использовать `fs.write` несколько раз на том же файле, не дожидаясь обратного вызова.

Для этого сценария, настоятельно рекомендуется использовать `fs.createWriteStream`. В системе Linux, позиционные записи не работают, если файл открыт в режиме добавления. Ядро игнорирует аргумент `position` и всегда добавляет данные в конец файла.

---

```
fs.write(fd, data[, position[, encoding]], callback)
```

- `fd` - `<Число>`
- `data` - `<Строка>` | `<Буфер>`
- `position` - `<Число>`
- `encoding` - `<Строка>`
- `callback` - `<Функция>`

Записывает `data` (Данные) в файл, указанный с помощью `fd`.

Если `data` не экземпляр `Buffer`, то значение будет приведено к строке.

`position` относится к смещению от начала файла, в котором эти данные должны быть записаны. (смещение - величина, показывающая при относительном методе адресации смещение ячейки памяти относительно базового адреса, т.е. число адресуемых элементов (расстояние) между двумя ячейками памяти)

Если `typeof position !== 'number'` то данные будут записаны в текущей позиции. См `pwrite(2)`.

`encoding` является ожидаемой строкой кодирования.

Обратный вызов получит три аргумента `(err, written, string)`, где `written` определяет, сколько байтов должны быть записано в переданную строку. Обратите внимание, что записанные байты не являются тем же самым что и символы строки. См `Buffer.byteLength`.

В отличие от записи в буфер при, должна быть записана вся строка. Ни одна подстрока не может быть указана. Это происходит потому, что смещение в байтах полученных данных не может быть таким же, что и смещение в строке.

!!!warning ""

    Обратите внимание, что небезопасно использовать `fs.write` несколько раз на одном том же файле, не дожидаясь обратного вызова. Для этого сценария, настоятельно рекомендуется `fs.createWriteStream`.

В Linux, позиционные записи не работают, если файл открыт в режиме добавления. Ядро игнорирует позицию аргумента и всегда добавляет данные в конец файла.

## fs.writeSync()

```
fs.writeSync(fd, buffer, offset, length[, position])
```

- `fd` - `<Число>`
- `buffer` - `<Строка>` | `<Буфер>`
- `offset` - `<Число>`
- `length` - `<Число>`
- `position` - `<Число>`

---

```
fs.writeSync(fd, data[, position[, encoding]])
```

- `fd` - `<Число>`
- `data` - `<Строка>` | `<Буфер>`
- `position` - `<Число>`
- `encoding` - `<Строка>`

Синхронная версия `fs.write()`. Возвращает количество записанных байтов.

## fs.writeFile()

```
fs.writeFile(file, data[, options], callback)
```

- `file` - `<Строка>` | `<Буфер>` | `<Число>` имя файла или файловый дескриптор
- `data` - `<Строка>` | `<Буфер>`
- `options` - `<Object>` | `<Строка>`
  : - `encoding` - `<Строка>` | `<Null>` (По умолчанию `utf8`)
  : - `mode` - `<Число>` (По умолчанию `0o666`)
  : - `flag` - `<Строка>` (По умолчанию `w`)
- `callback` - `<Функция>`

Асинхронно записывает данные в файл, заменяя файл, если он уже существует. `data` может быть строкой или буфером. Опция `ENCODING` игнорируется, если `data` является буфером. По умолчанию это `UTF-8`.

Пример:

```js
fs.writeFile('message.txt', 'Hello Node.js', (err) => {
  if (err) throw err;
  console.log("It's saved!");
});
```

Если `options` является строкой то она определяет кодирование.

Пример:

```js
fs.writeFile(
  'message.txt',
  'Hello Node.js',
  'utf8',
  callback
);
```

Любой заданный дескриптор файла должен поддерживать запись.

!!!warning ""

    Обратите внимание, что это небезопасно использовать `fs.writeFile` несколько раз на том же файле, не дожидаясь обратного вызова. Для этого сценария, настоятельно рекомендуется `fs.createWriteStream`.

Если дескриптор файла задан как файл, то он не будет автоматически закрыт.

## fs.writeFileSync()

```
fs.writeFileSync(file, data[, options])
```

- `file` - `<Строка>` | `<Буфер>` | `<Число>` имя файла или файловый дескриптор
- `data` - `<Строка>` | `<Буфер>`
- `options` - `<Object>` | `<Строка>`
  : - `encoding` - `<Строка>` | `<Null>` (По умолчанию `utf8`)
  : - `mode` - `<Число>` (По умолчанию `0o666`)
  : - `flag` - `<Строка>` (По умолчанию `w`)

Синхронная версия `fs.writeFile()`. Возвращает `undefined`.
